# Available property mappers

In previous sections we've already seen how

to create data objects where the keys of the

payload differ from the property names of the data object. It is also possible

to transform data objects to an

array/json/... where the keys of the payload differ from the property names of the data object.

These mappings can be set manually put the package also provide a set of mappers that can be used to automatically map

property names:

```
classContractDataextendsData{publicfunction__construct(#[MapName(CamelCaseMapper::class)]publicstring$name,#[MapName(SnakeCaseMapper::class)]publicstring$recordCompany,#[MapName(newProvidedNameMapper('country field'))]publicstring$country,#[MapName(StudlyCaseMapper::class)]publicstring$cityName,#[MapName(LowerCaseMapper::class)]publicstring$addressLine1,#[MapName(UpperCaseMapper::class)]publicstring$addressLine2,) {
    }
}
```

Creating the data object can now be done as such:

```
ContractData::from(['name'=>'Rick Astley','record_company'=>'RCA Records','country field'=>'Belgium','CityName'=>'Antwerp','addressline1'=>'some address line 1','ADDRESSLINE2'=>'some address line 2',
]);
```

When transforming such a data object the payload will look like this:

```
{"name":"Rick Astley","record_company":"RCA Records","country field":"Belgium","CityName":"Antwerp","addressline1":"some address line 1","ADDRESSLINE2":"some address line 2"}
```

In Packages






# Commands

### On this page

1. make:data

## # # make:data

You can easily generate new data objects with the artisan command make:data:

```
php artisan make:data PostData
```

By default, this command puts data objects in the App\Data namespace, this can be changed as such:

```
php artisan make:data PostData --namespace=DataTransferObjects
```

By default, the command creates a new data object within the \App\Data namespace and suffixes the class with Data, this can be changed by adding the following lines to the data.php config file:

```
'commands'=> [/*
     * Provides default configuration for the `make:data` command. These settings can be overridden with options
     * passed directly to the `make:data` command for generating single Data classes, or if not set they will
     * automatically fall back to these defaults. See `php artisan make:data --help` for more information
     */'make'=> [/*
         * The default namespace for generated Data classes. This exists under the application's root namespace,
         * so the default 'Data` will end up as '\App\Data', and generated Data classes will be placed in the
         * app/Data/ folder. Data classes can live anywhere, but this is where `make:data` will put them.
         */'namespace'=>'Data',/*
         * This suffix will be appended to all data classes generated by make:data, so that they are less likely
         * to conflict with other related classes, controllers or models with a similar name without resorting
         * to adding an alias for the Data object. Set to a blank string (not null) to disable.
         */'suffix'=>'Data',
    ],
]
```

Performance

Traits and interfaces






# Creating a cast

### On this page

1. Null
2. Castables
3. Casting iterable values
4. Combining casts and transformers

Casts take simple values and cast them into complex types. For example, 16-05-1994T00:00:00+00 could be cast into a Carbon object with the same date.

A cast implements the following interface:

```
interfaceCast{publicfunctioncast(DataProperty$property,mixed$value,array$properties,CreationContext$context):mixed;
}
```

A cast receives the following:

- property a DataProperty object which represents the property for which the value is cast. You can read more about the internal structures of the package here
- value the value that should be cast
- properties an array of the current properties that will be used to create the data object
- creationContext the context in which the data object is being created you'll find the following info here:
  - dataClass the data class which is being created
  - validationStrategy the validation strategy which is being used
  - mapPropertyNames whether property names should be mapped
  - disableMagicalCreation whether to use the magical creation methods or not
  - ignoredMagicalMethods the magical methods which are ignored
  - casts a collection of global casts

In the end, the cast should return a casted value.

When the cast is unable to cast the value, an Uncastable object should be returned.

## # # Null

A cast like a transformer never receives a null value, this is because the package will always keep a null value as null because we don't want to create values out of thin air. If you want to replace a null value, then use a magic method.

## # # Castables

You may want to allow your application's value objects to define their own custom casting logic. Instead of attaching the custom cast class to your object, you may alternatively attach a value object class that implements the Spatie\LaravelData\Casts\Castable interface:

```
classForgotPasswordRequestextendsData{publicfunction__construct(#[WithCastable(Email::class)]publicEmail$email,) {
    }
}
```

When using Castable classes, you may still provide arguments in the WithCastable attribute. The arguments will be passed to the dataCastUsing method:

```
classDuplicateEmailCheckextendsData{publicfunction__construct(#[WithCastable(Email::class,normalize:true)]publicEmail$email,) {
    }
}
```

By combining "castables" with PHP's anonymous classes, you may define a value object and its casting logic as a single castable object. To accomplish this, return an anonymous class from your value object's dataCastUsing method. The anonymous class should implement the Cast interface:

```
<?phpnamespaceSpatie\LaravelData\Tests\Fakes\Castables;useSpatie\LaravelData\Casts\Cast;useSpatie\LaravelData\Casts\Castable;useSpatie\LaravelData\Support\Creation\CreationContext;useSpatie\LaravelData\Support\DataProperty;classEmailimplementsCastable{publicfunction__construct(publicstring$email) {

  }publicstaticfunctiondataCastUsing(...$arguments):Cast{returnnewclassimplementsCast{publicfunctioncast(DataProperty$property,mixed$value,array$properties,CreationContext$context):mixed{returnnewEmail($value);
        }
    };
  }
}
```

## # # Casting iterable values

We saw earlier that you can cast all sorts of values in an array or Collection which are not data objects, for this to work, you should implement the IterableItemCast interface:

```
interfaceIterableItemCast{publicfunctioncastIterableItem(DataProperty$property,mixed$value,array$properties,CreationContext$context):mixed;
}
```

The castIterableItem method is called for each item in an array or Collection when being cast, you can check the iterableItemType property of DataProperty-&gt;type to get the type the items should be transformed into.

## # # Combining casts and transformers

You can combine casts and transformers in one class:

```
classToUpperCastAndTransformerimplementsCast, Transformer{publicfunctioncast(DataProperty$property,mixed$value,array$properties,CreationContext$context):string{returnstrtoupper($value);
    }publicfunctiontransform(DataProperty$property,mixed$value,TransformationContext$context):string{returnstrtoupper($value);
    }
}
```

Within your data object, you can use the WithCastAndTransformer attribute to use the cast and transformer:

```
classSongDataextendsData{publicfunction__construct(publicstring$title,#[WithCastAndTransformer(SomeCastAndTransformer::class)]publicstring$artist,) {
    }
}
```

Pipeline

Creating a transformer






# Creating a rule inferrer

Rule inferrers will try to infer validation rules for properties within a data object.

A rule inferrer can be created by implementing the RuleInferrer interface:

```
interfaceRuleInferrer{publicfunctionhandle(DataProperty$property,PropertyRules$rules,ValidationContext$context):PropertyRules;
}
```

A collection of previous inferred rules is given, and a DataProperty object which represents the property for which the value is transformed. You can read more about the internal structures of the package here.

The ValidationContext is also injected, this contains the following info:

- payload the current payload respective to the data object which is being validated
- fullPayload the full payload which is being validated
- validationPath the path from the full payload to the current payload

The RulesCollection contains all the rules for the property represented as ValidationRule objects.

You can add new rules to it:

```
$rules->add(newMin(42));
```

When adding a rule of the same kind, a previous version of the rule will be removed:

```
$rules->add(newMin(42));$rules->add(newMin(314));$rules->all();// [new Min(314)]
```

Adding a string rule can be done as such:

```
$rules->add(newRule('min:42'));
```

You can check if the collection contains a type of rule:

```
$rules->hasType(Min::class);
```

Or remove certain types of rules:

```
$rules->removeType(Min::class);
```

In the end, a rule inferrer should always return a RulesCollection.

Rule inferrers need to be manually defined within the data.php config file.

Creating a transformer

Use with Inertia






# Creating a transformer

### On this page

1. Combining transformers and casts

Transformers take complex values and transform them into simple types. For example, a Carbon object could be transformed to 16-05-1994T00:00:00+00.

A transformer implements the following interface:

```
interfaceTransformer{publicfunctiontransform(DataProperty$property,mixed$value,TransformationContext$context):mixed;
}
```

The following parameters are provided:

- property: a DataProperty object which represents the property for which the value is transformed. You can read more about the internal structures of the package here
- value: the value that should be transformed, this will never be null
- context: a TransformationContext object which contains the current transformation context with the following properties:
  - transformValues indicates if values should be transformed or not
  - mapPropertyNames indicates if property names should be mapped or not
  - wrapExecutionType the execution type that should be used for wrapping values
  - transformers a collection of transformers that can be used to transform values

In the end, the transformer should return a transformed value.

## # # Combining transformers and casts

You can transformers and casts in one class:

```
classToUpperCastAndTransformerimplementsCast, Transformer{publicfunctioncast(DataProperty$property,mixed$value,array$properties,CreationContext$context):string{returnstrtoupper($value);
    }publicfunctiontransform(DataProperty$property,mixed$value,TransformationContext$context):string{returnstrtoupper($value);
    }
}
```

Within your data object, you can use the WithCastAndTransformer attribute to use the cast and transformer:

```
classSongDataextendsData{publicfunction__construct(publicstring$title,#[WithCastAndTransformer(SomeCastAndTransformer::class)]publicstring$artist,) {
    }
}
```

Creating a cast

Creating a rule inferrer






# Eloquent casting

### On this page

1. Casting data collections
2. Using defaults for null database values
3. Using encryption with data objects and collections

Since data objects can be created from arrays and be easily transformed into arrays back again, they are excellent to be used

with Eloquent casts:

```
classSongextendsModel{protected$casts= ['artist'=>ArtistData::class,
    ];
}
```

Now you can store a data object in a model as such:

```
Song::create(['artist'=>newArtistData(name:'Rick Astley',age: 22),
]);
```

It is also possible to use an array representation of the data object:

```
Song::create(['artist'=> ['name'=>'Rick Astley','age'=> 22
    ]
]);
```

This will internally be converted to a data object which you can later retrieve as such:

```
Song::findOrFail($id)->artist;// ArtistData object
```

### # # Abstract data objects

Sometimes you have an abstract parent data object with multiple child data objects, for example:

```
abstractclassRecordConfigextendsData{publicfunction__construct(publicint$tracks,) {}
}classCdRecordConfigextendsRecordConfig{publicfunction__construct(int$tracks,publicint$bytes,) {parent::__construct($tracks);
    }
}classVinylRecordConfigextendsRecordConfig{publicfunction__construct(int$tracks,publicint$rpm,) {parent::__construct($tracks);
    }
}
```

A model can have a JSON field which is either one of these data objects:

```
classRecordextendsModel{protected$casts= ['config'=>RecordConfig::class,
    ];
}
```

You can then store either a CdRecordConfig or a VinylRecord in the config field:

```
$cdRecord=Record::create(['config'=>newCdRecordConfig(tracks: 12,bytes: 1000),
]);$vinylRecord=Record::create(['config'=>newVinylRecordConfig(tracks: 12,rpm: 33),
]);$cdRecord->config;// CdRecordConfig object$vinylRecord->config;// VinylRecordConfig object
```

When a data object class is abstract and used as an Eloquent cast, then this feature will work out of the box.

The child data object value of the model will be stored in the database as a JSON string with the class name and the data object properties:

```
{"type":"\\App\\Data\\CdRecordConfig","data":{"tracks": 12,"bytes": 1000}}
```

When retrieving the model, the data object will be instantiated based on the type key in the JSON string.

#### # # Abstract data object with collection

You can use with collection.

```
classRecordextendsModel{protected$casts= ['configs'=>DataCollection::class.':'.RecordConfig::class,
    ];
}
```

#### # # Abstract data class morphs

By default, the type key in the JSON string will be the fully qualified class name of the child data object. This can break your application quite easily when you refactor your code. To prevent this, you can add a morph map like with Eloquent models. Within your AppServiceProvivder you can add the following mapping:

```
useSpatie\LaravelData\Support\DataConfig;app(DataConfig::class)->enforceMorphMap(['cd_record_config'=>CdRecordConfig::class,'vinyl_record_config'=>VinylRecordConfig::class,
]);
```

## # # Casting data collections

It is also possible to store data collections in an Eloquent model:

```
classArtistextendsModel{protected$casts= ['songs'=>DataCollection::class.':'.SongData::class,
    ];
}
```

A collection of data objects within the Eloquent model can be made as such:

```
Artist::create(['songs'=> [newSongData(title:'Never gonna give you up',artist:'Rick Astley'),newSongData(title:'Together Forever',artist:'Rick Astley'),
    ],
]);
```

It is also possible to provide an array instead of a data object to the collection:

```
Artist::create(['songs'=> [
        ['title'=>'Never gonna give you up','artist'=>'Rick Astley'],
        ['title'=>'Together Forever','artist'=>'Rick Astley']
    ],
]);
```

## # # Using defaults for null database values

By default, if a database value is null, then the model attribute will also be null. However, sometimes you might want to instantiate the attribute with some default values.

To achieve this, you may provide an additional default Cast Parameter to ensure the caster gets instantiated.

```
classSongextendsModel{protected$casts= ['artist'=>ArtistData::class.':default',
    ];
}
```

This will ensure that the ArtistData caster is instantiated even when the artist attribute in the database is null.

You may then specify some default values in the cast which will be used instead.

```
classArtistDataextendsData{publicstring$name='Default name';
}
```

```
Song::findOrFail($id)->artist->name;// 'Default name'
```

### # # Nullable collections

You can also use the default argument in the case where you always want a DataCollection to be returned.

The first argument (after :) should always be the data class to be used with the DataCollection, but you can add default as a comma separated second argument.

```
classArtistextendsModel{protected$casts= ['songs'=>DataCollection::class.':'.SongData::class.',default',
    ];
}
```

```
$artist=Artist::create(['songs'=>null]);$artist->songs;// DataCollection$artist->songs->count();// 0
```

## # # Using encryption with data objects and collections

Similar to Laravel's native encrypted casts, you can also encrypt data objects and collections.

When retrieving the model, the data object will be decrypted automatically.

```
classArtistextendsModel{protected$casts= ['songs'=>DataCollection::class.':'.SongData::class.',encrypted',
    ];
}
```

Transforming data

Transforming to TypeScript






# Get data from a class quickly

By adding the WithData trait to a Model, Request or any class that can be magically be converted to a data object,

you'll enable support for the getData method. This method will automatically generate a data object for the object it

is called upon.

For example, let's retake a look at the Song model we saw earlier. We can add the WithData trait as follows:

```
classSongextendsModel{useWithData;protected$dataClass=SongData::class;
}
```

Now we can quickly get the data object for the model as such:

```
Song::firstOrFail($id)->getData();// A SongData object
```

We can do the same with a FormRequest, we don't use a property here to define the data class but use a method instead:

```
classSongRequestextendsFormRequest{useWithData;protectedfunctiondataClass():string{returnSongData::class;
    }
}
```

Now within a controller where the request is injected, we can get the data object like this:

```
classSongController{publicfunction__invoke(SongRequest$request):SongData{$data=$request->getData();$song=Song::create($data->toArray());return$data;
    }
}
```

Validation attributes

Performance






# Internal structures

### On this page

1. DataClass
2. DataProperty
3. DataMethod
4. DataParameter
5. DataType
6. DataPropertyType
7. DataTypeKind
8. NamedType
9. UnionType / IntersectionType

This package has some internal structures which are used to analyze data objects and their properties. They can be

helpful when writing casts, transformers or rule inferrers.

## # # DataClass

The DataClass represents the structure of a data object and has the following properties:

- name the name of the data class
- properties all the DataProperty's of the class (more on that later)
- methods all the magical creation DataMethods of the class (more on that later)
- constructorMethod the constructor DataMethod of the class
- isReadOnly is the class read only
- isAbstract is the class abstract
- appendable is the class implementing AppendableData
- includeable is the class implementing IncludeableData
- responsable is the class implementing ResponsableData
- transformable is the class implementing TransformableData
- validatable is the class implementing ValidatableData
- wrappable is the class implementing WrappableData
- emptyData the the class implementing EmptyData
- attributes a collection of resolved attributes assigned to the class
- dataCollectablePropertyAnnotations the property annotations of the class used to infer the data collection type
- allowedRequestIncludes the allowed request includes of the class
- allowedRequestExcludes the allowed request excludes of the class
- allowedRequestOnly the allowed request only of the class
- allowedRequestExcept the allowed request except of the class
- outputMappedProperties properties names which are mapped when transforming the data object
- transformationFields structure of the transformation fields

## # # DataProperty

A data property represents a single property within a data object.

- name the name of the property
- className the name of the class of the property
- type the DataPropertyType of the property (more on that later)
- validate should the property be automatically validated
- computed is the property computed
- hidden will the property be hidden when transforming the data object
- isPromoted is the property constructor promoted
- isReadOnly is the property read only
- hasDefaultValue has the property a default value
- defaultValue the default value of the property
- cast the cast assigned to the property
- transformer the transformer assigned to the property
- inputMappedName the name used to map a property name given
- outputMappedName the name used to map a property name onto
- attributes a collection of resolved attributes assigned to the property

## # # DataMethod

A data method represents a method within a data object.

- name the name of the method
- parameters all the DataParameter's and DataPropertys of the method (more on that later)
- isStatic whether the method is static
- isPublic whether the method is public
- isCustomCreationMethod whether the method is a custom creation method (=magical creation method)
- returnType the DataType of the return value (more on that later)

## # # DataParameter

A data parameter represents a single parameter/property within a data method.

- name the name of the parameter
- isPromoted is the property/parameter constructor promoted
- hasDefaultValue has the parameter a default value
- defaultValue the default value of the parameter
- type the DataType of the parameter (more on that later)

## # # DataType

A data type represents a type within a data object.

- Type can be a NamedType, UnionType or IntersectionType (more on that later)
- isNullable can the type be nullable
- isMixed is the type a mixed type
- kind the DataTypeKind of the type (more on that later)

## # # DataPropertyType

Extends from the DataType and has the following additional properties:

- isOptional can the type be optional
- lazyType the class of the lazy type for the property
- dataClass the data object class of the property or the data object class of the collection it collects
- dataCollectableClass the collectable type of the data objects
- kind the DataTypeKind of the type (more on that later)

## # # DataTypeKind

An enum representing the kind of type of a property/parameter with respect to the package:

- Default: a non package specific type
- DataObject: a data object
- DataCollection: a DataCollection of data objects
- DataPaginatedCollection: a DataPaginatedCollection of data objects
- DataCursorPaginatedCollection: a DataCursorPaginatedCollection of data objects
- DataArray: an array of data objects
- DataEnumerable: a Enumerable of data objects
- DataPaginator: a Paginator of data objects
- DataCursorPaginator: a CursorPaginator of data objects

## # # NamedType

Represents a named PHP type with the following properties:

- name the name of the type
- builtIn is the type a built-in type
- acceptedTypes an array of accepted types as string
- kind the DataTypeKind of the type (more on that later)
- dataClass the data object class of the property or the data object class of the collection it collects
- dataCollectableClass the collectable type of the data objects
- isCastable wetter the type is a Castable

## # # UnionType / IntersectionType

Represents a union or intersection of types with the following properties:

- types an array of types (can be NamedType, UnionType or IntersectionType)

Use with Livewire

Mapping rules






# Mapping rules

It is possible to map the names properties going in and out of your data objects using: MapOutputName, MapInputName

and MapName attributes. But sometimes it can be quite hard to follow where which name can be used. Let's go through

some case:

In the data object:

```
classUserDataextendsData{publicfunction__construct(#[MapName('favorite_song')]// name mappingpublicLazy|SongData$song,#[RequiredWith('song')]// In validation rules, use the original namepublicstring$title,) {
     }publicstaticfunctionallowedRequestExcept():?array{return['song',// Use the original name when defining includes, excludes, excepts and only];
     }publicfunctionrules(ValidContext$context):array{return['song'=>'required',// Use the original name when defining validation rules];
    }// ...}
```

When creating a data object:

```
UserData::from(['favorite_song'=> ...,// You can use the mapped or original name here'title'=>'some title']);
```

When adding an include, exclude, except or only:

```
UserData::from(User::first())->except('song');// Always use the original name here
```

Within a request query, you can use the mapped or original name:

```
https://spatie.be/my-account?except[]=favorite_song
```

When validating a data object or getting rules for a data object, always use the original name:

```
$data= ['favorite_song'=> 123,'title'=>'some title',
];UserData::validate($data)UserData::getValidationRules($data)
```

Internal structures

Validation attributes






# Normalizers

This package allows you to dynamically create data objects from any kind of object. For example, you can use an

eloquent model to create a data object like this:

```
SongData::from(Song::findOrFail($id));
```

A Normalizer will take a payload like a model and will transform it into an array, so it can be used in the pipeline (see further).

By default, there are five normalizers:

- ModelNormalizer will cast eloquent models
- ArrayableNormalizer will cast Arrayable's
- ObjectNormalizer will cast stdObject's
- ArrayNormalizer will cast arrays
- JsonNormalizer will cast json strings

A sixth normalizer can be optionally enabled:

- FormRequestNormalizer will normalize a form request by calling the validated method

Normalizers can be globally configured in config/data.php, and can be configured on a specific data object by overriding the normalizers method.

```
classSongDataextendsData{publicfunction__construct(// ...) {
    }publicstaticfunctionnormalizers():array{return[ModelNormalizer::class,ArrayableNormalizer::class,ObjectNormalizer::class,ArrayNormalizer::class,JsonNormalizer::class,
        ];
    }
}
```

A normalizer implements the Normalizer interface and should return an array representation of the payload, or null if it cannot normalize the payload:

```
classArrayableNormalizerimplementsNormalizer{publicfunctionnormalize(mixed$value):?array{if(!$valueinstanceofArrayable) {returnnull;
        }return$value->toArray();
    }
}
```

Normalizers are executed in the same order as they are defined in the normalize method. The first normalizer not returning null will be used to normalize the payload. Magical creation methods always have precedence over normalizers.

Working with dates

Pipeline






# Performance

### On this page

1. Caching
2. Configuration
3. Testing

Laravel Data is a powerful package that leverages PHP reflection to infer as much information as possible. While this approach provides a lot of benefits, it does come with a minor performance overhead. This overhead is typically negligible during development, but it can become noticeable in a production environment with a large number of data objects.

Fortunately, Laravel Data is designed to operate efficiently without relying on reflection. It achieves this by allowing you to cache the results of its complex analysis. This means that the performance cost is incurred only once, rather than on every request. By caching the analysis results before deploying your application to production, you ensure that a pre-analyzed, cached version of the data objects is used, significantly improving performance.

## # # Caching

Laravel Data provides a command to cache the analysis results of your data objects. This command will analyze all of your data objects and store the results in a Laravel cache of your choice:

```
php artisan data:cache-structures
```

That's it, the command will search for all the data objects in your application and cache the analysis results. Be sure to always run this command after creating or modifying a data object or when deploying your application to production.

## # # Configuration

The caching mechanism can be configured in the data.php config file. By default, the cache store is set to the default cache store of your application. You can change this to any other cache driver supported by Laravel. A prefix can also be set for the cache keys stored:

```
'structure_caching'=> ['cache'=> ['store'=>'redis','prefix'=>'laravel-data',
    ],
],
```

To find the data classes within your application, we're using the php-structure-discoverer package. This package allows you to configure the directories that will be searched for data objects. By default, the app/data directory is searched recursively. You can change this to any other directory or directories:

```
'structure_caching'=> ['directories'=> [app_path('Data'),
    ],
],
```

Structure discoverer uses reflection (enabled by default) or a PHP parser to find the data objects. You can disable the reflection-based discovery and thus use the PHP parser discovery as such:

```
'structure_caching'=> ['reflection_discovery'=> ['enabled'=>false,
    ],
],
```

Since we cannot depend on reflection, we need to tell the parser what data objects are exactly and where to find them. This can be done by adding the laravel-data directory to the config directories:

```
'structure_caching'=> ['directories'=> [app_path('Data'),base_path('vendor/spatie/laravel-data/src'),
    ],
],
```

When using reflection discovery, the base directory and root namespace can be configured as such if you're using a non-standard directory structure or namespace

```
'structure_caching'=> ['reflection_discovery'=> ['enabled'=>true,'base_path'=>base_path(),'root_namespace'=>null,
    ],
],
```

The caching mechanism can be disabled by setting the enabled option to false:

```
'structure_caching'=> ['enabled'=>false,
],
```

You can read more about reflection discovery here.

## # # Testing

When running tests, the cache is automatically disabled. This ensures that the analysis results are always up-to-date during development and testing. And that the cache won't interfere with your caching mocks.

Get data from a class quickly

Commands






# Pipeline

### On this page

1. Preparing data for the pipeline
2. Extending the pipeline within your data class

The data pipeline allows you to configure how data objects are constructed from a payload. In the previous chapter we

saw that a data object created from a payload will be first normalized into an array. This array is passed into the

pipeline.

The pipeline exists of multiple pipes which will transform the normalized data into a collection of property values

which can be passed to the data object constructor.

By default, the pipeline exists of the following pipes:

- AuthorizedDataPipe checks if the user is authorized to perform the request
- MapPropertiesDataPipe maps the names of properties
- FillRouteParameterPropertiesDataPipe fills property values from route parameters
- ValidatePropertiesDataPipe validates the properties
- DefaultValuesDataPipe adds default values for properties when they are not set
- CastPropertiesDataPipe casts the values of properties

Each result of the previous pipe is passed on into the next pipe, you can define the pipes on an individual data object

as such:

```
classSongDataextendsData{publicfunction__construct(// ...) {
    }publicstaticfunctionpipeline():DataPipeline{returnDataPipeline::create()
            ->into(static::class)
            ->through(AuthorizedDataPipe::class)
            ->through(MapPropertiesDataPipe::class)
            ->through(FillRouteParameterPropertiesDataPipe::class)
            ->through(ValidatePropertiesDataPipe::class)
            ->through(DefaultValuesDataPipe::class)
            ->through(CastPropertiesDataPipe::class);
    }
}
```

Each pipe implements the DataPipe interface and should return an array of properties:

```
interfaceDataPipe{publicfunctionhandle(mixed$payload,DataClass$class,array$properties,CreationContext$creationContext):array;
}
```

The handle method has several arguments:

- payload the non normalized payload
- class the DataClass object for the data object more info
- properties the key-value properties which will be used to construct the data object
- creationContext the context in which the data object is being created you'll find the following info here:
  - dataClass the data class which is being created
  - validationStrategy the validation strategy which is being used
  - mapPropertyNames whether property names should be mapped
  - disableMagicalCreation whether to use the magical creation methods or not
  - ignoredMagicalMethods the magical methods which are ignored
  - casts a collection of global casts

When using a magic creation methods, the pipeline is not being used (since you manually overwrite how a data object is

constructed). Only when you pass in a request object a minimal version of the pipeline is used to authorize and validate

the request.

## # # Preparing data for the pipeline

Sometimes you need to make some changes to the payload after it has been normalized, but before they are sent into the data pipeline. You can do this using the prepareForPipeline method as follows:

```
classSongMetadata{publicfunction__construct(publicstring$releaseYear,publicstring$producer,) {}
}classSongDataextendsData{publicfunction__construct(publicstring$title,publicSongMetadata$metadata,) {}publicstaticfunctionprepareForPipeline(array$properties):array{$properties['metadata'] =Arr::only($properties, ['release_year','producer']);return$properties;
    }
}
```

Now it is possible to create a data object as follows:

```
$songData=SongData::from(['title'=>'Never gonna give you up','release_year'=>'1987','producer'=>'Stock Aitken Waterman',
]);
```

## # # Extending the pipeline within your data class

Sometimes you want to send your payload first through a certain pipe without creating a whole new pipeline, this can be done as such:

```
classSongDataextendsData{publicstaticfunctionpipeline():DataPipeline{returnparent::pipeline()->firstThrough(GuessCasingForKeyDataPipe::class);
    }
}
```

Normalizers

Creating a cast






# Traits and interfaces

Laravel data, is built to be as flexible as possible. This means that you can use it in any way you want.

For example, the Data class we've been using throughout these docs is a class implementing a few data interfaces and traits:

```
useIlluminate\Contracts\Support\Responsable;useSpatie\LaravelData\Concerns\AppendableData;useSpatie\LaravelData\Concerns\BaseData;useSpatie\LaravelData\Concerns\ContextableData;useSpatie\LaravelData\Concerns\EmptyData;useSpatie\LaravelData\Concerns\IncludeableData;useSpatie\LaravelData\Concerns\ResponsableData;useSpatie\LaravelData\Concerns\TransformableData;useSpatie\LaravelData\Concerns\ValidateableData;useSpatie\LaravelData\Concerns\WrappableData;useSpatie\LaravelData\Contracts\AppendableDataasAppendableDataContract;useSpatie\LaravelData\Contracts\BaseDataasBaseDataContract;useSpatie\LaravelData\Contracts\EmptyDataasEmptyDataContract;useSpatie\LaravelData\Contracts\IncludeableDataasIncludeableDataContract;useSpatie\LaravelData\Contracts\ResponsableDataasResponsableDataContract;useSpatie\LaravelData\Contracts\TransformableDataasTransformableDataContract;useSpatie\LaravelData\Contracts\ValidateableDataasValidateableDataContract;useSpatie\LaravelData\Contracts\WrappableDataasWrappableDataContract;abstractclassDataimplementsResponsable, AppendableDataContract, BaseDataContract, TransformableDataContract, IncludeableDataContract, ResponsableDataContract, ValidateableDataContract, WrappableDataContract, EmptyDataContract{useResponsableData;useIncludeableData;useAppendableData;useValidateableData;useWrappableData;useTransformableData;useBaseData;useEmptyData;useContextableData;
}
```

These traits and interfaces allow you to create your own versions of the base Data class, and add your own functionality to it.

An example of such custom base data classes are the Resource and Dto class.

Each interface (and corresponding trait) provides a piece of functionality:

- BaseData provides the base functionality of the data package to create data objects
- BaseDataCollectable provides the base functionality of the data package to create data collections
- ContextableData provides the functionality to add context for includes and wraps to the data object/collectable
- IncludeableData provides the functionality to add includes, excludes, only and except to the data object/collectable
- TransformableData provides the functionality to transform the data object/collectable
- ResponsableData provides the functionality to return the data object/collectable as a response
- WrappableData provides the functionality to wrap the transformed data object/collectable
- AppendableData provides the functionality to append data to the transformed data payload
- EmptyData provides the functionality to get an empty version of the data object
- ValidateableData provides the functionality to validate the data object
- DeprecatableData provides the functionality to add deprecated functionality to the data object

Commands

In Packages






# Transforming to TypeScript

### On this page

1. Installation of extra package
2. Usage

Thanks to the typescript-transformer package, it is possible to

automatically transform data objects into TypeScript definitions.

For example, the following data object:

```
classDataObjectextendsData{publicfunction__construct(publicnull|int$nullable,publicint$int,publicbool$bool,publicstring$string,publicfloat$float,/**@varstring[]*/publicarray$array,publicLazy|string$lazy,publicOptional|string$optional,publicSimpleData$simpleData,/**@var\Spatie\LaravelData\Tests\Fakes\SimpleData[]*/publicDataCollection$dataCollection,)
    {
    }
}
```

... can be transformed to the following TypeScript type:

```
{
    nullable: number | null;
    int: number;
    bool: boolean;
    string: string;
    float: number;
    array: Array<string>;
    lazy? : string;
    optional? : string;
    simpleData: SimpleData;
    dataCollection: Array<SimpleData>;
}
```

## # # Installation of extra package

First, you must install the spatie/laravel-typescript-transformer into your project.

```
composer require spatie/laravel-typescript-transformer
```

Next, publish the config file of the typescript-transformer package with:

```
php artisan vendor:publish --tag=typescript-transformer-config
```

Finally, add the Spatie\LaravelData\Support\TypeScriptTransformer\DataTypeScriptTransformer transformer to the

transformers in the typescript-transformer.php config file.

If you're using the DtoTransformer provided by the package, then be sure to put the DataTypeScriptTransformer before the DtoTransformer.

## # # Usage

Annotate each data object that you want to transform to Typescript with a /\*_ @typescript _/ annotation or

a #[TypeScript] attribute.

To generate the typescript file

, run this command:

```
php artisan typescript:transform
```

If you want to transform all the data objects within your application to TypeScript, you can use

the DataTypeScriptCollector, which should be added to the collectors in typescript-transformer.php.

If you're using the DefaultCollector provided by the package, then be sure to put the DataTypeScriptCollector before the DefaultCollector.

### # # Optional types

An optional or lazy property will automatically be transformed into an optional type within TypeScript:

```
classDataObjectextendsData{publicfunction__construct(publicLazy|string$lazy,publicOptional|string$optional,)
    {
    }
}
```

This will be transformed into:

```
{
    lazy? : string;
    optional? : string;
}
```

If you want to have optional typed properties in TypeScript without typing your properties optional or lazy within PHP,

then you can use the Optional attribute from the typescript-transformer package.

Don't forget to alias it as TypeScriptOptional when you're already using this package's Optional type!

```
useSpatie\TypeScriptTransformer\Attributes\OptionalasTypeScriptOptional;classDataObjectextendsData{publicfunction__construct(#[TypeScriptOptional]publicint$id,publicstring$someString,publicOptional|string$optional,)
    {
    }
}
```

Eloquent casting

Working with dates






# Use with Inertia

### On this page

1. Lazy properties

Inertia.js lets you quickly build modern single-page React, Vue, and Svelte apps using classic server-side routing and controllers.

Laravel Data works excellent with Inertia.

You can pass a complete data object to an Inertia response:

```
returnInertia::render('Song',SongsData::from($song));
```

## # # Lazy properties

This package supports lazy properties, which can be manually included or excluded.

Inertia has a similar concept called lazy data evaluation, where some properties wrapped in a closure only get evaluated and included in the response when explicitly asked.

Inertia v2 introduced the concept of deferred props, which allows to defer the loading of certain data until after the initial page render.

This package can output specific properties as Inertia lazy or deferred props as such:

```
classSongDataextendsData{publicfunction__construct(publicLazy|string$title,publicLazy|string$artist,publicLazy|string$lyrics,) {
    }publicstaticfunctionfromModel(Song$song):self{returnnewself(Lazy::inertia(fn() =>$song->title),Lazy::closure(fn() =>$song->artist)Lazy::inertiaDeferred(fn() =>$song->lyrics)
        );
    }
}
```

We provide three kinds of lazy properties:

- Lazy::inertia() Never included on first visit, optionally included on partial reloads
- Lazy::closure() Always included on first visit, optionally included on partial reloads
- Lazy::inertiaDeferred() Included when ready, optionally included on partial reloads

Now within your JavaScript code, you can include the properties as such:

```
router.reload((url, {only: ['title'],
});
```

### # # Auto lazy Inertia properties

We already saw earlier that the package can automatically make properties Lazy, the same can be done for Inertia properties.

It is possible to rewrite the previous example as follows:

```
useSpatie\LaravelData\Attributes\AutoClosureLazy;useSpatie\LaravelData\Attributes\AutoInertiaLazy;useSpatie\LaravelData\Attributes\AutoInertiaDeferred;classSongDataextendsData{publicfunction__construct(#[AutoInertiaLazy]publicLazy|string$title,#[AutoClosureLazy]publicLazy|string$artist,#[AutoInertiaDeferred]publicLazy|string$lyrics,) {
    }
}
```

If all the properties of a class should be either Inertia or closure lazy, you can use the attributes on the class level:

```
#[AutoInertiaLazy]classSongDataextendsData{publicfunction__construct(publicLazy|string$title,publicLazy|string$artist,) {
    }
}
```

Creating a rule inferrer

Use with Livewire






# Working with dates

### On this page

1. Multiple date formats
2. Casting dates in a different time zone
3. Changing time zones

Dates can be hard, there are tons of formats to cast them from or transform them to. Within the data.php config file a

default date format can be set:

```
'date_format'=>DATE_ATOM,
```

Now when using the DateTimeInterfaceCast or DateTimeInterfaceTransformer the format defined will be used

```
#[WithCast(DateTimeInterfaceCast::class)]#[WithTransformer(DateTimeInterfaceTransformer::class)]publicDateTime$date
```

It is also possible to manually set the format;

```
#[WithCast(DateTimeInterfaceCast::class,format:DATE_ATOM)]#[WithTransformer(DateTimeInterfaceTransformer::class,format:DATE_ATOM)]publicDateTime$date
```

When casting the data object will use the type of the property to cast a date string into, so if you want to

use Carbon, that's perfectly possible:

```
#[WithCast(DateTimeInterfaceCast::class)]publicCarbon$date
```

You can even manually specify the type the date string should be cast to:

```
#[WithCast(DateTimeInterfaceCast::class,type:CarbonImmutable::class)]public$date
```

## # # Multiple date formats

Sometimes your application might use different date formats, for example, you receive dates from an IOS and React

application. These use different underlying date formats. In such case you can add an array to the date_format key

within the data.php config file:

```
'date_format'=> [DATE_ATOM,'Y-m-d'],
```

Now when casting a date, a valid format will be searched. When none can be found, an exception is thrown.

When a transformers hasn't explicitly stated its format, the first format within the array is used.

## # # Casting dates in a different time zone

Sometimes a date can be in a different timezone than the timezone you application uses. For example, if your application uses Europe/Brussels but your date is in UTC:

```
#[WithCast(DateTimeInterfaceCast::class,timeZone:'UTC')]publicDateTime$date
```

The date will be created with the UTC timezone but will be the same as in the Europe/Brussels timezone.

## # # Changing time zones

When casting a date you may want to set an alternative timezone this can be achieved as such:

```
#[WithCast(DateTimeInterfaceCast::class,setTimeZone:'Europe/Brussels')]publicDateTime$date
```

In this case the time will be transformed, if our original time was in UTC then one or two hours (depending on summer time) will be added.

You can also change the timezone of a property which is getting transformed:

```
#[WithTransformer(DateTimeInterfaceTransformer::class,setTimeZone:'Europe/Brussels')]publicDateTime$date
```

Transforming to TypeScript

Normalizers
